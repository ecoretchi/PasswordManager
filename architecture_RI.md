# Архитектура Password Manager

## 1. Общая структура системы

### 1.1. Модульная архитектура

Приложение построено на модульной архитектуре с четким разделением ответственности:

- **Модули состояния** (`state.js`) — управление глобальным состоянием приложения
- **Модули криптографии** (`crypto.js`) — шифрование и расшифровка данных
- **Модули хранения** (`storage.js`) — работа с localStorage и управление версиями
- **Модули авторизации** (`auth.js`) — локальная авторизация и управление пользователями
- **Модули Google Drive** (`js/googleDrive/`) — интеграция с Google Drive и синхронизация
- **Модули UI** (`ui.js`, `passwords.js`, `categories.js`) — пользовательский интерфейс
- **Модули импорта/экспорта** (`importExport.js`) — работа с CSV файлами
- **Модули логирования** (`logger.js`) — централизованное логирование
- **Модули интернационализации** (`i18n.js`, `translations.js`) — поддержка нескольких языков

### 1.2. Типы пользователей

Система поддерживает два типа пользователей:

- **Local** — локальный пользователь, данные хранятся только локально
- **Google** — пользователь с синхронизацией через Google Drive

---

## 2. Система хранения данных

### 2.1. Локальное хранилище (localStorage)

Для каждого пользователя создается отдельный набор ключей в `localStorage`:

- `PM_ACTIVE_USER` — идентификатор активного пользователя (незашифрованный указатель)
- `PM_DATA::<userId>` — зашифрованные данные пользователя (base64)
- `PM_DATA::<userId>_salt` — соль для расшифровки (base64, незашифрованная)
- `PM_DATA::<userId>_version` — версия данных (незашифрованная, для быстрого доступа)
- `PM_DATA::<userId>_hashVersion` — хэш-версия данных для определения конфликтов (SHA-256)
- `PM_DATA::<userId>_lastCloudModifiedTime` — последнее известное время изменения файла в облаке
- `PM_DATA::<userId>_lastCloudHashVersion` — последний известный хэш облачных данных

### 2.2. Структура зашифрованных данных

Внутри зашифрованного значения хранится полная информация о пользователе:

- Идентификатор пользователя и отображаемое имя
- Тип входа (Local или Google)
- Список категорий паролей
- Массив записей паролей (каждая запись содержит скрытый Hash ID для синхронизации)
- Настройки видимости паролей
- Настройки подтверждения удаления
- Google токены (если тип входа Google) — хранятся в зашифрованном виде
- Версия данных и время последнего изменения

### 2.3. Облачное хранилище (Google Drive)

В файле Google Drive хранится обертка с метаданными:

- Идентификатор пользователя
- Зашифрованные данные (encryptedData)
- Соль для расшифровки (encryptionSalt) — критически важно для работы на другом устройстве
- Версия данных
- Хэш-версия данных (hashVersion)
- Временные метки изменения и синхронизации

---

## 3. Система шифрования

### 3.1. Мастер-ключ

Мастер-ключ является основой безопасности системы:

- Никогда не сохраняется ни локально, ни в облаке
- Требуется для всех операций (Local и Google)
- Используется вместе с salt для генерации ключа шифрования через PBKDF2
- Без правильного мастер-ключа и salt расшифровка невозможна

### 3.2. Соль (Salt)

Соль обеспечивает уникальность ключа шифрования:

- Генерируется один раз при создании пользователя (16 байт)
- Хранится незашифрованной (не является секретом)
- Критически важна для расшифровки данных
- Хранится локально и в Google Drive для работы на разных устройствах

### 3.3. Процесс шифрования

1. Получение мастер-ключа от пользователя
2. Получение salt (локально или из облака)
3. Генерация ключа шифрования: PBKDF2(userId + masterKey, salt, 100000 итераций, SHA-256)
4. Шифрование данных: AES-GCM с использованием сгенерированного ключа
5. Сохранение зашифрованных данных и salt

### 3.4. Процесс расшифровки

1. Получение мастер-ключа от пользователя
2. Получение salt (локально или из Google Drive)
3. Генерация ключа шифрования: PBKDF2(userId + masterKey, salt, 100000 итераций, SHA-256)
4. Расшифровка данных: AES-GCM с использованием сгенерированного ключа
5. Парсинг JSON и восстановление структуры данных

---

## 4. Система авторизации

### 4.1. Локальный вход (Local)

**Алгоритм:**

1. Пользователь вводит логин и мастер-ключ
2. Определение статуса пользователя:
   - Если данные существуют локально — существующий пользователь
   - Если данных нет — новый пользователь
3. Инициализация шифрования:
   - Для существующего пользователя: используется существующая salt
   - Для нового пользователя: генерируется новая salt
4. Загрузка или создание данных
5. Сохранение данных и установка активного пользователя

### 4.2. Вход через Google

**Алгоритм:**

1. Выполнение Google-аутентификации через OAuth 2.0
2. Получение Google токенов (accessToken, refreshToken, fileId, email)
3. Ввод мастер-ключа пользователем
4. Определение сценария пользователя:

   **Сценарий A: Пользователь существует локально**
   - Используется существующая локальная salt
   - Выполняется синхронизация с Google Drive
   - Разрешение конфликтов версий при необходимости

   **Сценарий B: Пользователь существует только в Google Drive**
   - Загружается salt из Google Drive
   - Salt сохраняется локально
   - Загружаются и расшифровываются данные из облака
   - Данные сохраняются локально

   **Сценарий C: Новый пользователь**
   - Генерируется новая salt
   - Создаются пустые данные с дефолтными категориями
   - Salt и данные загружаются в Google Drive

5. Сохранение Google токенов в зашифрованных данных
6. Установка активного пользователя

### 4.3. Обновление страницы

**Алгоритм:**

1. Проверка наличия активного пользователя (`PM_ACTIVE_USER`)
2. Если активный пользователь существует:
   - Проверка наличия локальных данных и salt
   - Если данные есть: показ окна ввода мастер-ключа
   - Если данных нет, но тип входа Google: загрузка salt и данных из облака
3. Если активного пользователя нет: показ стартового экрана входа

**Синхронизация при обновлении страницы:**

- При включенной функции Cloud Sync выполняется проверка версии данных в облаке
- Если облачная версия новее локальной, выполняется синхронизация из облака
- Если локальная версия актуальна, работа продолжается с локальными данными

### 4.4. Автоматическая повторная авторизация Google

**Механизм работы:**

1. При обнаружении истекшего токена доступа система автоматически запускает процесс повторной авторизации
2. Если master key уже введен (например, в `masterKeyOnlyModal`), он используется автоматически
3. Если master key недоступен, показывается модальное окно для его ввода
4. После получения master key автоматически открывается Google OAuth popup
5. После успешной авторизации токены обновляются и синхронизация продолжается

**Преимущества:**

- Прозрачность для пользователя — не требуется ручное вмешательство
- Использование уже введенного master key
- Автоматическая обработка ошибок 401 Unauthorized

---

## 5. Система синхронизации

### 5.1. Механизм debounce

Для предотвращения частых операций синхронизации используется механизм debounce:

- При изменении данных запускается таймер на 3 секунды
- Если в течение этого времени происходят новые изменения, таймер сбрасывается
- Синхронизация выполняется только после 3 секунд бездействия
- Версия данных инкрементируется только один раз за цикл debounce

### 5.2. Управление версиями

Система использует двойной механизм контроля версий:

- **Номер версии** — инкрементируется при каждом изменении данных
- **Hash Version** — SHA-256 хэш зашифрованных данных для определения фактического равенства содержимого

### 5.3. Правила определения конфликтов

**Правило 1: Версии совпадают, хэши совпадают**
- Данные идентичны
- Синхронизация не требуется
- Конфликтный диалог не отображается

**Правило 2: Версии совпадают, хэши различаются**
- Обнаружен конфликт содержимого
- Отображается диалог выбора направления синхронизации

**Правило 3: Версии различаются**
- Независимо от направления расхождения
- Всегда отображается диалог выбора

### 5.4. Проверка актуальности облачной версии

Перед каждой загрузкой данных в облако:

1. Получение метаданных файла из облака (без загрузки содержимого)
2. Сравнение `modifiedTime` с последним известным значением
3. Принятие решения:
   - Если данные не изменялись — выполнение загрузки
   - Если данные изменялись — загрузка из облака и показ диалога конфликта

### 5.5. Разрешение конфликтов

При обнаружении конфликта версий:

1. Получение статистики данных (количество категорий, паролей, размер) для локальных и облачных данных
2. Отображение диалога с информацией о конфликте и статистикой
3. Предоставление пользователю выбора:
   - Загрузка локальных данных в облако
   - Загрузка данных из облака
   - Отмена операции (переход в локальный режим)

### 5.6. Слияние данных при синхронизации

При загрузке данных из облака выполняется слияние с локальными данными:

- Сопоставление записей по Hash ID
- Объединение уникальных записей
- Сохранение записей, существующих только локально
- Обновление записей, существующих в обеих версиях
- Удаление записей, существующих только в облаке (при необходимости)

---

## 6. Идентификация записей

### 6.1. Hash ID

Каждая запись пароля имеет скрытый уникальный идентификатор:

- Генерируется автоматически при создании записи (32 байта)
- Не отображается в пользовательском интерфейсе
- Используется как первичный ключ для синхронизации

### 6.2. Составной ключ

Для операций синхронизации используется комбинация:

- Hash ID (первичный идентификатор)
- Service (вспомогательный атрибут)
- Login (вспомогательный атрибут)

Это позволяет:
- Однозначно идентифицировать каждую запись
- Поддерживать несколько записей с одинаковыми Service и Login
- Избежать конфликтов при слиянии данных

### 6.3. Поведение при синхронизации

- Сопоставление записей выполняется по Hash ID
- Service и Login используются как вспомогательные атрибуты
- Отсутствие Hash ID считается признаком новой записи

---

## 7. Управление черновиками

### 7.1. Временные записи

При создании новой записи:

- Создается временная (черновая) запись с пустыми полями
- Запись помечается флагом `_isDraft`
- Черновые записи не участвуют в синхронизации

### 7.2. Активация записи

Запись перестает быть черновиком при:

- Вводе данных в поле Service
- Вводе данных в поле Login
- Вводе данных в поле Password
- Выборе категории
- Сохранении заметки

### 7.3. Синхронизация

- Синхронизация активируется только для записей без флага `_isDraft`
- При удалении черновой записи синхронизация не запускается
- Флаг `_isDraft` не сохраняется в зашифрованных данных

---

## 8. Система управления токенами Google

### 8.1. Автоматическая проверка валидности

Перед каждой операцией синхронизации:

- Выполняется проверка валидности токена доступа через Google OAuth API
- Если токен валиден, операция продолжается
- Если токен истек, запускается процесс обновления

### 8.2. Обновление токена

При истечении токена доступа:

1. Попытка обновления через refresh token
2. Если refresh token доступен и валиден — токен обновляется автоматически
3. Если refresh token отсутствует или истек — запускается процесс повторной авторизации

### 8.3. Обработка ошибок 401

При получении ошибки 401 Unauthorized:

- Система автоматически определяет истечение токена
- Выполняется попытка обновления токена
- При успешном обновлении запрос повторяется с новым токеном
- При неудаче пользователю предлагается повторная авторизация

### 8.4. Автоматическая повторная авторизация

Когда refresh token недоступен:

1. Проверка наличия master key (переданного параметром или в модальных окнах)
2. Если master key доступен — автоматический запуск Google OAuth popup
3. Если master key недоступен — показ модального окна для ввода
4. После успешной авторизации токены обновляются и работа продолжается

---

## 9. Пользовательский интерфейс

### 9.1. Модальные окна

Система использует три типа модальных окон:

- **masterPasswordModal** — полное окно входа (логин + мастер-ключ + Google)
- **masterKeyOnlyModal** — упрощенное окно для ввода только мастер-ключа (при обновлении страницы)
- **syncConflictModal** — диалог разрешения конфликтов синхронизации

### 9.2. Управление состоянием UI

- Категории отображаются с устранением визуальных дубликатов (case-insensitive)
- Пароли отображаются в таблице с поддержкой фильтрации и поиска
- Статус синхронизации отображается в верхней части интерфейса
- Версия данных отображается в статусе Cloud Sync

### 9.3. Отображение версии

В статусе Cloud Sync отображается:

- "CLOUD SYNCED v.X" — где X — номер версии документа в облаке
- Обновление происходит после каждой успешной синхронизации
- При локальном режиме отображается "LOCAL SYNC"

---

## 10. Логирование и отладка

### 10.1. Категории логов

Система использует префиксы для категоризации:

- `[AUTH]` — логи авторизации
- `[SYNC]` — логи синхронизации
- `[SYNC ERROR]` — ошибки синхронизации
- `[USER ACTION]` — действия пользователя

### 10.2. Уровни логирования

- **INFO** — информационные сообщения (успешные операции)
- **WARN** — предупреждения (конфликты версий, нестандартные ситуации)
- **ERROR** — ошибки (неудачные операции, проблемы с токенами)

### 10.3. Детальное логирование

Логируются следующие события:

- Проверка валидности токенов
- Операции синхронизации (загрузка/выгрузка)
- Обнаружение конфликтов версий
- Действия пользователя (создание, редактирование, удаление записей)
- Ошибки и исключения

---

## 11. Обработка ошибок

### 11.1. Ошибки шифрования

- Неверный мастер-ключ — показ ошибки и запрос повторного ввода
- Отсутствие salt — попытка загрузки из облака (для Google пользователей)
- Ошибки расшифровки — логирование и показ пользователю

### 11.2. Ошибки синхронизации

- Ошибки сети — повторные попытки с обработкой таймаутов
- Ошибки 401 — автоматическое обновление токена и повтор запроса
- Ошибки 404 — создание нового файла в облаке
- Конфликты версий — показ диалога выбора пользователю

### 11.3. Ошибки авторизации

- Истечение токена — автоматическая повторная авторизация
- Отмена авторизации пользователем — возврат на экран входа
- Ошибки OAuth — логирование и показ сообщения пользователю

---

## 12. Работа на разных устройствах

### 12.1. Новое устройство (Google вход)

**Сценарий:**

1. Пользователь открывает приложение на новом устройстве
2. Выполняет вход через Google
3. Локальных данных нет — загружаются из Google Drive
4. Salt загружается из облака и сохраняется локально
5. Данные расшифровываются с использованием master key
6. Приложение работает с синхронизацией

### 12.2. Существующее устройство

**Сценарий:**

1. Пользователь открывает приложение
2. Определяется активный пользователь
3. Данные загружаются из локального хранилища
4. Выполняется проверка версии с облаком
5. При необходимости выполняется синхронизация

---

## 13. Безопасность

### 13.1. Хранение данных

- Мастер-ключ никогда не сохраняется
- Данные всегда хранятся в зашифрованном виде
- Salt не является секретом, но критически важна для расшифровки
- Google токены хранятся в зашифрованных данных

### 13.2. Шифрование

- Использование PBKDF2 с 100000 итерациями для генерации ключа
- Использование AES-GCM для шифрования данных
- Уникальная salt для каждого пользователя
- Невозможность расшифровки без правильного мастер-ключа и salt

### 13.3. Управление токенами

- Токены обновляются только через официальный Google OAuth flow
- Refresh token используется только для обновления access token
- Автоматическое обновление токенов без сохранения в открытом виде

---

## 14. Производительность

### 14.1. Оптимизация синхронизации

- Использование debounce для предотвращения частых синхронизаций
- Проверка метаданных перед загрузкой содержимого
- Кэширование метаданных для быстрой проверки изменений

### 14.2. Оптимизация UI

- Динамическое обновление только измененных элементов
- Устранение визуальных дубликатов без изменения данных
- Ленивая загрузка данных при необходимости

---

## 15. Масштабируемость

### 15.1. Модульная структура

- Четкое разделение ответственности между модулями
- Возможность независимого развития компонентов
- Легкость добавления новых функций

### 15.2. Управление данными

- Использование Hash ID для уникальной идентификации записей
- Поддержка множественных записей с одинаковыми Service/Login
- Эффективное слияние данных при синхронизации

---

## 16. Заключение

Архитектура Password Manager обеспечивает:

- **Безопасность** — надежное шифрование данных с использованием мастер-ключа и salt
- **Удобство** — автоматическая синхронизация и управление токенами
- **Надежность** — обработка ошибок и конфликтов на всех уровнях
- **Масштабируемость** — модульная структура и эффективное управление данными
- **Прозрачность** — детальное логирование и понятные диалоги для пользователя

Система спроектирована для работы на различных устройствах с автоматической синхронизацией через Google Drive, обеспечивая при этом высокий уровень безопасности и удобства использования.
