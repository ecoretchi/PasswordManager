# Полный план архитектуры Password Manager с учетом Salt

## 1. Первый вход

Показываем экран:
- **Логин** (поле ввода)
- **Мастер-ключ** (поле ввода)
- **Вход через Google** (кнопка)

---

## 2. Мастер-ключ

- Мастер-ключ шифрует данные в `LocalStorage` и **никогда не сохраняется**.
- Он нужен **всегда** (Local и Google).
- Используется вместе с salt для генерации ключа шифрования через PBKDF2.
- Без правильного мастер-ключа и salt расшифровка невозможна.

---

## 3. Ключи в LocalStorage

Для каждого пользователя хранится **отдельная запись** в `LocalStorage`.

### Ключи:
- `PM_DATA::<userId>` — зашифрованные данные (base64)
- `PM_DATA::<userId>_salt` — соль для расшифровки (base64, незашифрованная, не секретная)
- `PM_DATA::<userId>_version` — версия данных (незашифрованная, для быстрого доступа)

где `userId` = локальный логин или Google-аккаунт (email).

### Внутри зашифрованного значения (`PM_DATA::<userId>`) хранится:

```javascript
{
    userId: "user@example.com",
    displayName: "user@example.com",
    loginType: "Local" | "Google",
    passwordCategories: ['Games', 'Email', 'Banks', 'Social Networks', 'Work', 'Misc'],
    passwords: [],
    passwordsVisible: {},
    deleteWithoutConfirm: true | false,
    googleToken: {
        accessToken: "...",
        refreshToken: "...",
        fileId: "...",
        email: "user@example.com"
    } | null,
    version: 1,
    modifiedAt: "2025-12-14T22:32:10.023Z"
}
```

---

## 4. Данные в Google Drive

В файле Google Drive хранится (незашифрованная обёртка):

```javascript
{
    userId: "user@example.com",
    encryptedData: "<зашифрованные данные из PM_DATA::<userId>>",
    encryptionSalt: "<base64 encoded salt>",  // КРИТИЧНО для работы на другом компьютере
    version: 1,
    modifiedAt: "2025-12-14T22:32:10.023Z",
    lastSync: "2025-12-14T22:32:11.616Z"
}
```

**Важно:** `encryptionSalt` должна быть в Google Drive, чтобы можно было расшифровать данные на другом компьютере.

---

## 5. Запоминание текущего пользователя

Чтобы при обновлении страницы понимать, какой объект расшифровывать, храним отдельную **незашифрованную** (служебную) запись:

- `PM_ACTIVE_USER` ? `<userId>`

Это не секрет (это только указатель на нужный ключ), поэтому шифровать необязательно.

---

## 6. Локальный вход (Local)

### Алгоритм:

1. Пользователь вводит `userId` (логин) и мастер-ключ
2. Проверяем существование пользователя:
   - Если `PM_DATA::<userId>` существует ? **существующий пользователь**
   - Если не существует ? **новый пользователь**
3. Инициализация шифрования:
   - **Если существующий:**
     - Используем существующую salt из `PM_DATA::<userId>_salt`
     - Если salt нет ? ошибка: "Salt not found"
     - `initializeEncryption(userId, masterKey, true)` // useExistingSalt = true
   - **Если новый:**
     - Генерируем новую salt
     - Сохраняем salt в `PM_DATA::<userId>_salt`
     - `initializeEncryption(userId, masterKey, false)` // useExistingSalt = false
4. Загрузка данных:
   - Если существующий: расшифровываем `PM_DATA::<userId>`
   - Если новый: создаём пустые данные с дефолтными категориями
5. Сохранение:
   - Сохраняем данные в `PM_DATA::<userId>` (всё зашифровано мастер-ключом)
   - Выставляем `PM_ACTIVE_USER = <userId>`

---

## 7. Вход через Google

### Алгоритм:

1. Выполняем Google-аутентификацию
2. Получаем Google Token (accessToken, refreshToken, fileId, email)
3. Пользователь вводит мастер-ключ
4. **Определяем статус пользователя:**

   **Шаг 4.1: Проверяем локальное существование**
   ```javascript
   const hasLocalData = userDataExists(userId); // Проверяет PM_DATA::<userId>
   const hasLocalSalt = localStorage.getItem(getUserDataKey(userId) + '_salt') !== null;
   ```
   
   **Шаг 4.2: Проверяем существование в Google Drive**
   ```javascript
   let hasCloudData = false;
   let cloudSalt = null;
   try {
       const cloudFile = await fetchGoogleDriveFile();
       if (cloudFile && cloudFile.userId === userId) {
           hasCloudData = true;
           cloudSalt = cloudFile.encryptionSalt;
       }
   } catch (error) {
       hasCloudData = false; // Файл не найден
   }
   ```
   
   **Шаг 4.3: Определяем сценарий и salt**
   
   **Сценарий A: Пользователь существует локально**
   - `hasLocalData = true` и `hasLocalSalt = true`
   - Используем существующую salt из `PM_DATA::<userId>_salt`
   - `initializeEncryption(userId, masterKey, true)` // useExistingSalt = true
   - Синхронизируем с Google Drive (загружаем или загружаем в облако)
   
   **Сценарий B: Пользователь существует только в Google Drive**
   - `hasLocalData = false`, но `hasCloudData = true` и `cloudSalt` есть
   - Загружаем salt из Google Drive: `cloudSalt`
   - Сохраняем salt локально: `PM_DATA::<userId>_salt = cloudSalt`
   - `initializeEncryption(userId, masterKey, true)` // useExistingSalt = true, но salt из Google Drive
   - Загружаем и расшифровываем данные из Google Drive
   - Сохраняем расшифрованные данные локально
   
   **Сценарий C: Новый пользователь**
   - `hasLocalData = false` и `hasCloudData = false`
   - Генерируем новую salt
   - Сохраняем salt локально: `PM_DATA::<userId>_salt`
   - `initializeEncryption(userId, masterKey, false)` // useExistingSalt = false
   - Создаём пустые данные с дефолтными категориями
   - Сохраняем данные локально
   - Загружаем salt и данные в Google Drive

5. Сохранение Google Token:
   - Сохраняем Google Token внутри `PM_DATA::<userId>` (в поле `googleToken`)
   - Всё зашифровано мастер-ключом
6. Синхронизация с Google Drive:
   - Загружаем `encryptedData` из `PM_DATA::<userId>`
   - Загружаем `encryptionSalt` из `PM_DATA::<userId>_salt`
   - Загружаем `version` из `PM_DATA::<userId>_version`
   - Формируем объект и загружаем в Google Drive
7. Выставляем `PM_ACTIVE_USER = <userId>`

---

## 8. Обновление страницы

### Алгоритм:

1. Читаем `PM_ACTIVE_USER`
2. Если `PM_ACTIVE_USER` задан:
   
   **Шаг 2.1: Проверяем наличие данных локально**
   ```javascript
   const activeUserId = getActiveUserId();
   const hasLocalData = userDataExists(activeUserId);
   const hasLocalSalt = localStorage.getItem(getUserDataKey(activeUserId) + '_salt') !== null;
   ```
   
   **Шаг 2.2: Если данные есть локально**
   - Если `hasLocalData = true` и `hasLocalSalt = true`:
     - Показываем окно **"Введите мастер-ключ"**
     - Salt уже есть, можно расшифровать
   - Если `hasLocalData = true`, но `hasLocalSalt = false`:
     - Ошибка: "Salt not found locally"
     - Если тип входа был Google ? пытаемся загрузить salt из Google Drive
     - Если тип входа был Local ? показываем ошибку
   
   **Шаг 2.3: Если данных нет локально**
   - Если `hasLocalData = false`:
     - Проверяем, есть ли Google токены (в незашифрованном виде или нужно загрузить)
     - Если тип входа был Google:
       - Загружаем данные из Google Drive (включая `encryptionSalt`)
       - Сохраняем salt локально: `PM_DATA::<userId>_salt`
       - Сохраняем данные локально: `PM_DATA::<userId>`
       - Показываем окно **"Введите мастер-ключ"**
     - Если тип входа был Local:
       - Показываем стартовый экран (данные только локально, их нет)

3. Если `PM_ACTIVE_USER` отсутствует:
   - Показываем стартовый экран входа (логин/мастер-ключ/Google)

### Синхронизация при обновлении страницы

При обновлении страницы пользователь вводит Master Key для доступа к зашифрованным данным.

Если включена функция Cloud Sync (Google Cloud), приложение выполняет проверку версии данных, хранящихся в облаке, и сравнивает её с текущей локальной версией.

Если версия данных в облаке выше, выполняется синхронизация: локальные данные обновляются данными из облака.

Если локальная версия актуальна, приложение продолжает работу с текущими данными без выполнения синхронизации.

Данный шаг гарантирует, что пользователь всегда работает с наиболее актуальной версией зашифрованных данных, независимо от устройства или сессии.

### Отображение версии в статусе Cloud Sync

В верхней части интерфейса приложения отображается статус синхронизации. При включенной функции Cloud Sync вместо текста "cloud sync" отображается "CLOUD SYNCED v.X", где X — номер текущей версии документа, хранящейся в облаке.

После каждой успешной синхронизации (как при загрузке данных в облако, так и при загрузке из облака) статус автоматически обновляется, отображая актуальный номер версии документа из облака.

Это позволяет пользователю в любой момент видеть, какая версия данных находится в облачном хранилище.

---

## 9. Проверка мастер-ключа

### Алгоритм (при вводе мастер-ключа в окне):

1. Получаем `activeUserId` из `PM_ACTIVE_USER`
2. **Получаем salt:**
   
   **Шаг 2.1: Проверяем локальную salt**
   ```javascript
   const dataKey = getUserDataKey(activeUserId);
   let saltBase64 = localStorage.getItem(dataKey + '_salt');
   ```
   
   **Шаг 2.2: Если salt нет локально**
   - Если salt нет в localStorage:
     - Проверяем тип входа (из расшифрованных данных или пытаемся определить)
     - Если тип входа Google:
       - Загружаем salt из Google Drive (`encryptionSalt`)
       - Сохраняем salt локально: `PM_DATA::<userId>_salt`
     - Если тип входа Local:
       - Ошибка: "Salt not found locally. Data may be corrupted."

3. Инициализация шифрования:
   ```javascript
   await initializeEncryption(activeUserId, masterKey, true); // useExistingSalt = true
   ```
   - Использует salt (локальную или из Google Drive)
   - Генерирует ключ шифрования: `PBKDF2(userId + masterKey, salt)`

4. Попытка расшифровки:
   ```javascript
   const encryptedData = localStorage.getItem(getUserDataKey(activeUserId));
   const decryptedData = await decryptData(encryptedData);
   const data = JSON.parse(decryptedData);
   ```

5. Результат:
   - **Успех** ? мастер-ключ верный ? читаем тип входа и данные
   - **Ошибка** ? мастер-ключ неверный ? показываем ошибку и просим ввести правильный мастер-ключ

---

## 10. После расшифровки

### Алгоритм:

1. Читаем `loginType` из расшифрованных данных
2. Если `loginType === "Local"`:
   - Открываем менеджер паролей
   - Salt уже есть в localStorage
   - Инициализируем UI (категории, пароли, фильтры)

3. Если `loginType === "Google"`:
   
   **Шаг 3.1: Восстанавливаем Google токены**
   ```javascript
   const googleToken = data.googleToken;
   if (googleToken) {
       googleDriveAccessToken = googleToken.accessToken;
       googleDriveRefreshToken = googleToken.refreshToken;
       googleDriveFileId = googleToken.fileId;
       googleDriveUserEmail = googleToken.email;
       isGoogleSignIn = true;
   }
   ```
   
   **Шаг 3.2: Проверяем валидность токена**
   ```javascript
   const isValid = await checkGoogleTokenValidity(googleDriveAccessToken);
   ```
   
   **Шаг 3.3: Если токен валиден**
   - Открываем менеджер паролей
   - Запускаем синхронизацию с Google Drive
   - Инициализируем UI
   
   **Шаг 3.4: Если токен истёк**
   - Показываем диалог:
     - "Google token has expired. Do you want to sign in again?"
     - Кнопка **"Войти через Google"** (повторно):
       - Выполняет Google-аутентификацию
       - Получает новые токены
       - Сохраняет новые токены в зашифрованных данных
       - Обновляет данные в Google Drive
     - Кнопка **"Отмена"**:
       - Возврат на стартовый экран (логин/мастер-ключ/Google)
       - Очищаем `PM_ACTIVE_USER`

---

## 11. Отмена

Кнопка **"Отмена"** в окне ввода мастер-ключа:
- Очищает `PM_ACTIVE_USER`
- Возвращает на стартовый экран (логин/мастер-ключ/Google)
- Скрывает окно ввода мастер-ключа
- Показывает полное окно входа

---

## 12. Синхронизация с Google Drive

### При загрузке в Google Drive (`syncToGoogleDrive`):

1. Получаем зашифрованные данные: `PM_DATA::<userId>`
2. Получаем salt: `PM_DATA::<userId>_salt`
3. Получаем версию: `PM_DATA::<userId>_version`
4. Формируем объект:
   ```javascript
   {
       userId: currentUserLogin,
       encryptedData: encryptedData,
       encryptionSalt: saltBase64,  // КРИТИЧНО!
       version: currentVersion,
       modifiedAt: new Date().toISOString(),
       lastSync: new Date().toISOString()
   }
   ```
5. Загружаем в Google Drive
6. После успешной загрузки обновляем статус синхронизации для отображения актуальной версии в интерфейсе

### При загрузке из Google Drive (`syncFromGoogleDrive`):

1. Загружаем файл из Google Drive
2. Проверяем формат:
   - `userId` должен совпадать с `currentUserLogin`
   - `encryptedData` должен присутствовать (может быть пустым для новых файлов)
   - `encryptionSalt` должен присутствовать (**критично!**)
3. Сохраняем salt локально:
   ```javascript
   localStorage.setItem(getUserDataKey(currentUserLogin) + '_salt', jsonData.encryptionSalt);
   ```
4. Сохраняем данные локально:
   ```javascript
   localStorage.setItem(getUserDataKey(currentUserLogin), jsonData.encryptedData);
   ```
5. Сохраняем версию:
   ```javascript
   localStorage.setItem(getUserDataKey(currentUserLogin) + '_version', jsonData.version);
   ```
6. Расшифровываем данные с использованием salt из Google Drive
7. После успешной загрузки обновляем статус синхронизации для отображения актуальной версии из облака в интерфейсе

### Разрешение конфликтов версий:

При обнаружении конфликта версий (локальная версия отличается от облачной) система выполняет следующие действия:

1. **Получение статистики данных:**
   - Для локальных данных: извлекается статистика из текущих расшифрованных данных (количество категорий, паролей, размер данных)
   - Для облачных данных: временно расшифровываются данные из облака для получения статистики (без изменения текущего состояния)

2. **Детальное логирование:**
   - В лог записывается предупреждение (`logWarn`) с полной статистикой:
     - Локальная версия и статистика (количество категорий, паролей, размер данных)
     - Облачная версия и статистика (количество категорий, паролей, размер данных)
   - В консоль выводится детальная информация для отладки

3. **Диалог выбора направления синхронизации:**
   - Показывается модальное окно с информацией:
     - Сообщение о конфликте версий (локальная новее облачной или наоборот)
     - Таблица сравнения статистики (версия, категории, пароли, размер данных) для локальных и облачных данных
     - Предупреждение о том, что действие перезапишет данные и не может быть отменено
   - Пользователь может выбрать одно из трех действий:
     - **"Upload Local Data"** — загрузка локальных зашифрованных данных в облако с перезаписью облачной версии
     - **"Download Cloud Data"** — загрузка данных из облака с перезаписью локальной версии
     - **"Cancel"** — отмена операции синхронизации без внесения изменений; локальная и облачная версии остаются без изменений; переход в режим локального использования без синхронизации (LOCAL SYNC)

4. **Выполнение выбранного действия:**
   - **Upload Local Data:** выполняется загрузка локальных данных в облако (`syncToGoogleDrive`)
   - **Download Cloud Data:** выполняется загрузка данных из облака (`syncFromGoogleDrive`) с сохранением локально
   - **Cancel:** 
     - Отключается синхронизация с облаком (`isGoogleSignIn = false`)
     - Очищаются Google токены (`googleDriveAccessToken = null`, `googleDriveRefreshToken = null`, `googleDriveFileId = null`)
     - Останавливаются таймеры синхронизации
     - Статус обновляется на "LOCAL SYNC" (локальная синхронизация)
     - Приложение продолжает работу только с локальными данными

**Важно:** 
- Диалог подтверждения показывается при любом расхождении версий (локальная ? облачная)
- Такой подход исключает неявное поведение системы и гарантирует, что пользователь осознанно выбирает направление синхронизации при конфликте версий данных
- Если версии равны, синхронизация выполняется автоматически без подтверждения

---

### Автоматическое управление токенами Google

Для обеспечения непрерывной работы синхронизации с Google Drive реализован механизм автоматического управления токенами доступа:

1. **Проверка валидности токена перед синхронизацией:**
   - Перед каждой операцией синхронизации (`syncToGoogleDrive`, `syncFromGoogleDrive`) выполняется проверка валидности токена доступа через функцию `ensureValidGoogleToken()`
   - Проверка выполняется путем запроса к Google OAuth API (`tokeninfo` endpoint)
   - Если токен валиден, синхронизация продолжается

2. **Автоматическое обновление истекшего токена:**
   - Если токен доступа истек, система автоматически пытается обновить его с использованием `refreshToken`
   - Обновление выполняется через Google Identity Services API (`google.accounts.oauth2.initTokenClient`)
   - После успешного обновления новый токен сохраняется в глобальной переменной `googleDriveAccessToken` и устанавливается для `gapi.client`
   - Если обновление успешно, синхронизация продолжается с новым токеном

3. **Обработка ошибки 401 Unauthorized:**
   - При получении ошибки 401 (Unauthorized) от Google Drive API система автоматически:
     - Определяет, что токен истек
     - Выполняет попытку обновления токена через `ensureValidGoogleToken()`
     - При успешном обновлении повторяет исходный запрос с новым токеном
   - Обработка 401 реализована в следующих функциях:
     - `syncToGoogleDrive()` — при загрузке файла в облако
     - `getGoogleDriveFileMetadata()` — при получении метаданных файла
     - `fetchGoogleDriveFileData()` — при загрузке данных из облака

4. **Обработка неудачного обновления токена:**
   - Если обновление токена не удалось (например, `refreshToken` также истек), система:
     - Логирует ошибку в консоль
     - Обновляет статус синхронизации: "Token expired - please sign in again"
     - Прекращает операцию синхронизации
     - Пользователю необходимо выполнить повторный вход через Google

5. **Преимущества подхода:**
   - **Прозрачность для пользователя:** Токен обновляется автоматически без необходимости повторного входа
   - **Надежность:** Ошибки 401 обрабатываются автоматически с повторной попыткой операции
   - **Безопасность:** Токены не хранятся в открытом виде, обновление выполняется через защищенные API Google
   - **Улучшенный UX:** Пользователь не прерывает работу при истечении токена

**Технические детали:**
- Функция `ensureValidGoogleToken()` доступна глобально через `window.ensureValidGoogleToken` для использования в других модулях
- Проверка токена выполняется асинхронно через `checkGoogleTokenValidity(accessToken)`
- Обновление токена выполняется асинхронно через `refreshGoogleAccessToken(refreshToken)`
- Все операции с токенами логируются в консоль для отладки

---

## 13. План определения конфликтов версий и управления синхронизацией

### 1. Ограничения использования только номера версии

Использование только номера версии недостаточно для корректного определения состояния данных, так как он позволяет определить лишь направление изменений (локальная версия отстаёт или опережает облачную), но не гарантирует совпадение содержимого данных.

### 2. Введение хэша версии данных

Для повышения точности контроля изменений необходимо дополнительно хранить **Hash Version** — хэш, вычисляемый на основе содержимого зашифрованных данных.

Hash Version используется для определения фактического равенства данных независимо от номера версии.

**Технические детали:**
- Hash Version вычисляется с помощью алгоритма SHA-256
- Хэш вычисляется на основе зашифрованных данных (encryptedData)
- Hash Version хранится отдельно в `localStorage` с ключом `PM_DATA::<userId>_hashVersion`
- Hash Version также сохраняется в облаке вместе с данными в поле `hashVersion`

### 3. Правила сравнения версий и хэшей

При синхронизации выполняются следующие проверки:

**Правило 1: Версии совпадают, хэши совпадают**
- Данные идентичны
- Синхронизация не требуется
- Конфликтный диалог не отображается
- Приложение продолжает работу с текущими данными

**Правило 2: Версии совпадают, хэши различаются**
- Обнаружен конфликт содержимого
- Отображается диалог выбора направления синхронизации
- Пользователь выбирает, какую версию данных использовать

**Правило 3: Версии различаются (локальная ? облачная)**
- Независимо от направления расхождения версий
- Всегда отображается диалог выбора
- Пользователь самостоятельно определяет, какую версию данных использовать

### 4. Поведение интерфейса при конфликте

При отображении конфликтного диалога пользователь должен иметь возможность:

- **выбрать локальную версию данных** (Upload Local Data) — загрузка локальных данных в облако с перезаписью облачной версии
- **выбрать облачную версию данных** (Download Cloud Data) — загрузка данных из облака с перезаписью локальной версии
- **отменить операцию** (Cancel) — оставить обе версии без изменений, переход в режим локального использования без синхронизации

### 5. Гарантии корректности

Данный подход обеспечивает:

- **корректное выявление реальных конфликтов данных** — сравнение хэшей позволяет определить фактическое различие содержимого
- **исключение ложных конфликтов при идентичном содержимом** — если версии совпадают и хэши совпадают, данные идентичны, синхронизация не требуется
- **прозрачный и контролируемый процесс синхронизации для пользователя** — пользователь всегда видит диалог выбора при реальном конфликте данных

---

## 14. Проверка актуальности облачной версии перед загрузкой

### 1. Алгоритм работы

Перед каждой загрузкой данных в облако приложение сначала проверяет, изменялись ли данные в облаке с момента последней синхронизации.

**Шаги проверки:**

1. **Получение метаданных файла из облака** (без загрузки содержимого)
   - Используется Google Drive API для получения метаданных файла
   - Получаются поля: `modifiedTime`, `md5Checksum` (если доступен), `size`

2. **Сравнение с последними известными значениями**
   - Сравнивается `modifiedTime` файла с сохраненным `lastCloudModifiedTime`
   - Если `modifiedTime` изменился, считается, что данные в облаке были изменены

3. **Принятие решения:**
   - **Если данные в облаке не изменялись** (`modifiedTime` совпадает):
     - Выполняется загрузка локальной версии в облако
     - Обновляются метаданные (`lastCloudModifiedTime`, `lastCloudHashVersion`)
   
   - **Если данные в облаке изменялись** (`modifiedTime` отличается):
     - Считается, что возник конфликт
     - Данные загружаются из облака
     - Пользователю отображается диалог выбора между локальной и облачной версией
     - После выбора пользователя обновляются метаданные

### 2. Хранение метаданных

Для отслеживания состояния облачного файла используются глобальные переменные:

- `lastCloudModifiedTime` — последняя известная дата изменения файла в облаке
- `lastCloudHashVersion` — последний известный Hash Version облачных данных

Эти значения обновляются после каждой успешной синхронизации (как при загрузке, так и при выгрузке).

### 3. Преимущества подхода

- **Экономия трафика** — не требуется загружать содержимое файла для проверки изменений
- **Быстрая проверка** — получение метаданных выполняется быстрее, чем загрузка всего файла
- **Предотвращение конфликтов** — конфликты обнаруживаются до загрузки локальных данных в облако
- **Прозрачность для пользователя** — пользователь всегда видит диалог выбора при реальном конфликте

### 4. Обработка первого запуска

При первом запуске синхронизации (когда `lastCloudModifiedTime` равен `null`):
- Метаданные сохраняются после первой успешной синхронизации
- Последующие синхронизации используют сохраненные метаданные для сравнения

---

## 15. План идентификации и синхронизации записей

### 1. Критерий идентификации записи

Для корректной синхронизации данных каждая запись должна иметь уникальный идентификатор, используемый для сопоставления локальных и облачных данных.

В качестве логического критерия используются:

- **Service** (сервис)
- **Login** (логин пользователя)

Однако данных полей недостаточно для обеспечения полной уникальности, так как допускается существование нескольких записей с одинаковыми значениями Service и Login.

### 2. Генерация скрытого уникального идентификатора

При создании новой записи необходимо автоматически генерировать скрытый **Hash ID**, который:

- имеет фиксированную длину (рекомендуется 32 байта);
- не отображается в пользовательском интерфейсе;
- хранится внутри записи и используется только на уровне логики и синхронизации.

Hash ID является первичным уникальным идентификатором записи.

### 3. Составной ключ записи

Для операций синхронизации и разрешения конфликтов используется комбинация:

- **Hash ID**
- **Service**
- **Login**

Такой подход позволяет:

- однозначно идентифицировать каждую запись;
- поддерживать несколько записей с одинаковыми Service и Login;
- избежать конфликтов при merge-операциях между локальным и облачным хранилищами.

### 4. Поведение при синхронизации

При синхронизации:

- сопоставление записей выполняется по **Hash ID**;
- поля Service и Login используются как вспомогательные атрибуты;
- отсутствие Hash ID считается признаком новой записи и требует её создания.

### 5. Гарантии корректности

Данный подход обеспечивает:

- корректную двустороннюю синхронизацию;
- отсутствие перезаписи записей с одинаковыми Service/Login;
- масштабируемость архитектуры при росте количества записей и устройств.

---

## 14. Работа на новом компьютере

### Сценарий "новый компьютер" (Google вход):

1. Пользователь открывает приложение
2. Нет `PM_ACTIVE_USER` ? показывается стартовый экран
3. Пользователь нажимает "Войти через Google"
4. Выполняется Google-аутентификация
5. Получаются Google токены
6. Пользователь вводит мастер-ключ
7. Определение статуса пользователя:
   - `hasLocalData = false` (новый компьютер)
   - Проверяется Google Drive ? `hasCloudData = true`
   - Загружается `encryptionSalt` из Google Drive
8. Сохранение salt локально:
   ```javascript
   localStorage.setItem(getUserDataKey(userId) + '_salt', cloudSalt);
   ```
9. Сохранение данных локально:
   ```javascript
   localStorage.setItem(getUserDataKey(userId), encryptedData);
   ```
10. Выставляется `PM_ACTIVE_USER = userId`
11. Инициализация шифрования с salt из Google Drive:
    ```javascript
    await initializeEncryption(userId, masterKey, true); // Используем salt из Google Drive
    ```
12. Расшифровка данных:
    ```javascript
    await loadFromLocalStorage(userId);
    ```
13. Открывается менеджер паролей

---

## 15. Важные моменты про Salt

### Что такое Salt:
- Случайная последовательность байтов (16 байт)
- Используется в PBKDF2 для генерации ключа шифрования
- Уникальна для каждого пользователя
- Генерируется один раз при создании пользователя

### Почему Salt не секретна:
- Salt не раскрывает данные
- Нужна для расшифровки
- Стандартная практика — хранить salt отдельно от зашифрованных данных

### Где хранится Salt:
1. **Локально:** `PM_DATA::<userId>_salt` (для быстрого доступа)
2. **В Google Drive:** `encryptionSalt` (для работы на другом компьютере)

### Когда генерируется новая Salt:
- Только при создании нового пользователя
- Если пользователь существует (локально или в Google Drive) — используется существующая salt

### Без Salt невозможно:
- Расшифровать данные, даже зная правильный мастер-ключ
- Работать на новом компьютере без загрузки salt из Google Drive

---

## 16. Сводная таблица сценариев

| Сценарий | Локальные данные | Google Drive | Salt | Действие |
|----------|------------------|--------------|------|----------|
| Новый пользователь (Local) | Нет | Нет | Нет | Генерируем новую salt |
| Новый пользователь (Google) | Нет | Нет | Нет | Генерируем новую salt, загружаем в Google Drive |
| Существующий (Local) | Есть | Нет | Есть локально | Используем локальную salt |
| Существующий (Google, тот же компьютер) | Есть | Есть | Есть локально | Используем локальную salt, синхронизируем |
| Существующий (Google, новый компьютер) | Нет | Есть | Есть в Google Drive | Загружаем salt из Google Drive, сохраняем локально |
| Обновление страницы (Local) | Есть | Нет | Есть локально | Используем локальную salt |
| Обновление страницы (Google, тот же компьютер) | Есть | Есть | Есть локально | Используем локальную salt |
| Обновление страницы (Google, новый компьютер) | Нет | Есть | Есть в Google Drive | Загружаем salt из Google Drive |

---

## 17. Структура данных (схема)

### В LocalStorage:
```
PM_ACTIVE_USER ? "user@example.com"
PM_DATA::user@example.com ? "<зашифрованные данные>"
PM_DATA::user@example.com_salt ? "<base64 salt>"
PM_DATA::user@example.com_version ? "1"
```

### В Google Drive файле:
```json
{
    "userId": "user@example.com",
    "encryptedData": "<зашифрованные данные>",
    "encryptionSalt": "<base64 salt>",
    "version": 1,
    "modifiedAt": "2025-12-14T22:32:10.023Z",
    "lastSync": "2025-12-14T22:32:11.616Z"
}
```

### Внутри зашифрованных данных:
```json
{
    "userId": "user@example.com",
    "displayName": "user@example.com",
    "loginType": "Google",
    "passwordCategories": ["Games", "Email", "Banks", "Social Networks", "Work", "Misc"],
    "passwords": [],
    "passwordsVisible": {},
    "deleteWithoutConfirm": false,
    "googleToken": {
        "accessToken": "...",
        "refreshToken": "...",
        "fileId": "...",
        "email": "user@example.com"
    },
    "version": 1,
    "modifiedAt": "2025-12-14T22:32:10.023Z"
}
```

---

## 18. Алгоритм шифрования/расшифровки

### Шифрование:
1. Получаем мастер-ключ от пользователя
2. Получаем salt (локально или генерируем новую)
3. Генерируем ключ: `PBKDF2(userId + masterKey, salt, 100000 iterations, SHA-256)`
4. Шифруем данные: `AES-GCM(encryptionKey, data)`
5. Сохраняем зашифрованные данные и salt

### Расшифровка:
1. Получаем мастер-ключ от пользователя
2. Получаем salt (локально или из Google Drive)
3. Генерируем ключ: `PBKDF2(userId + masterKey, salt, 100000 iterations, SHA-256)`
4. Расшифровываем данные: `AES-GCM(encryptionKey, encryptedData)`
5. Парсим JSON и восстанавливаем данные

---

Этот план учитывает все сценарии работы с salt и обеспечивает работу на любом компьютере.

